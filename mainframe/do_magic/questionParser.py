import nltk
import do_magic.voila as voila
import do_magic.dataQuery as sqlQuery
import do_magic.answerFinder as answer
from nltk.corpus import wordnet

"""
    NERsearch find people:
        search for people in DB
        if person:
            person1 = person

    NERsearch find field:
        search for field in Look up table:
            if field:
                stat = field

    if person and person2:
        comparison
    elif person:
        if min/max:
            get min/max stat
        else: get stat

    else:
        get min/max based on flag
"""

def parseQuestion(question):
    tokenized = nltk.word_tokenize(question)
    nonMatchedWord = []  # list of words (NOT NOUNS) which may be used to break ties with spell checker.
    playerResults = []  # list of results generated by noun search.
    wordResults = []  # list of results generated by nonNouns
    statsResults = []
    capturedWords = []
    minimumQualifiers = ["minimum", "min", "least", "lowest", "smallest", "shortest", "bottom"]
    maximumQualifiers = ["maximum", "most", "max", "highest", "biggest", "tallest", "top", "heaviest"]

    # remove the pesky "'s" from tokenized, and capture words
    # todo set up chunking or similar to identify comparisons between players so triangulation doesn't
    #  always have to be called.

    min = False
    max = False
    when = False
    where = False
    year = 0
    for word in tokenized:
        if "\'" in word:
            tokenized.remove(word)
        elif word == "when":
            when = True
        elif word == "where":
            where = True
        elif word.isnumeric:
            if word > 1949 and word < 2019:
                year = word
        else:
            for element in minimumQualifiers:
                if word.lower() == element:
                    min = True
            for element in maximumQualifiers:
                if word.lower() == element:
                    max = True

    # DONE DO NOT MODIFY
    tokenized = voila.get_stopwords(tokenized)
    tokenized = voila.get_basewords(tokenized)
    voila.addToList(tokenized, capturedWords)
    raw_input_as_last_option = ''
    for word in tokenized:
        result = sqlQuery.search_phrase_DB(word)
        if result:
            voila.addToList(wordResults, result)
            raw_input_as_last_option = raw_input_as_last_option + word + ' '
        else:
            result = sqlQuery.search_player_dB(word)
            result_stat = sqlQuery.search_stats_DB(word)
            if result:
                voila.addToList(playerResults, result)
            if result_stat:
                voila.addToList(statsResults, result_stat)
            else:
                nonMatchedWord.append(word)
    # END DONE DO NOT MODIFY


    raw_input_as_last_option = raw_input_as_last_option.strip()
    tableName = "placeholder"
    playerName = "placeholder"


    #function 1 start
    tempResults = sqlQuery.search_phrase_DB_exact_match(raw_input_as_last_option)
    if tempResults:
        wordResults = tempResults
    else:
        wordResults = answer.processResults(wordResults, nonMatchedWord)  # processResults begins triangulation.
    # process results returns a tuple or list, if tuple we have triangulate, if not we have multiple entires.
    if isinstance(wordResults, tuple):
        tableName = voila.singlequoteSQLfix(wordResults[5])
    else:
        wordResults = raw_input_to_N_tuples(raw_input_as_last_option, wordResults)
        if isinstance(wordResults, tuple):
            tableName = voila.singlequoteSQLfix(wordResults[5])
        # return "there were multiple hits for your query please limit query to only one field or stat at a time"
    #function 1 end

    #begin switch/IF statements
    if tableName == "player_data": #switch case
        #function 2
        playerResults = answer.processResults(playerResults, nonMatchedWord)  # processResults begins triangulation.
        if isinstance(playerResults, tuple):
            playerName = voila.singlequoteSQLfix(playerResults[0])
        else:
            return playerResults
        #end function 2
    if tableName == "stats": #switch case
        #function 3
        if min:
            if year > 0:
                voila.addToList(statsResults, sqlQuery.search_stats_min_DB(wordResults[3], year))
                return statsResults[0][0]
            else:
                voila.addToList(statsResults, sqlQuery.search_stats_min_no_year_DB(wordResults[3]))
                return statsResults[0][0]
        elif max:
            if year > 0:
                voila.addToList(statsResults, sqlQuery.search_stats_max_DB(wordResults[3], year))
                return statsResults[0][0]
            else:
                voila.addToList(statsResults, sqlQuery.search_stats_max_no_year_DB(wordResults[3]))
                return statsResults[0][0]
        else:
            statsResults = answer.processResults(statsResults, nonMatchedWord)  # processResults begins triangulation.
        if year > 0:
            statsResults = answer.find_with_year(year, statsResults)
        elif max:
            search max of results #max of array
        elif min:
            search min of results #min of array
        elif not isinstance(statsResults, tuple):
            statsResults = voila.get_most_recent(statsResults)
        if isinstance(statsResults, tuple):
            playerName = voila.singlequoteSQLfix(statsResults[0])
            #     THE CONNECTION GOES HERE
            index_for_answer = wordResults[4]
            return statsResults[index_for_answer]
        else:
            return statsResults
            #end function 3



    return_info = answer.return_tablename_with_player_name(wordResults, playerName)

    if return_info == 0:
        return "unable to find match"

    return return_info


def raw_input_to_N_tuples(string, list_of_tuples):
    for row in list_of_tuples:
        if row[0] == string:
            return row
