import nltk
import do_magic.voila as voila
import do_magic.dataQuery as sqlQuery
import do_magic.answerFinder as answer
from nltk.corpus import wordnet

"""
    NERsearch find people:
        search for people in DB
        if person:
            person1 = person

    NERsearch find field:
        search for field in Look up table:
            if field:
                stat = field

    if person and person2:
        comparison
    elif person:
        if min/max:
            get min/max stat
        else: get stat

    else:
        get min/max based on flag
"""


def nerPersonTagging(question: str):
    find_persons = voila.structure_ne(voila.nltk_tagger(voila.process_text(question)))
    find_persons = [i[0] for i in find_persons]
    dict = {}
    if find_persons:
        for person in find_persons: dict[person] = [sqlQuery.search_stats_DB(person), sqlQuery.search_player_dB(person)]
        if checkifhit(dict): return False
    if not find_persons: return False
    return dict

def checkifhit(dict: dict):
    for i in dict.values():
        if len(i[0]) == 0 and len(i[1]) == 0: return True



def removeName_fromQuery(personhit, question: str):
    for person in personhit.keys():
        if person in question: question = question.replace(person, '')
    x = question.find("\'s")
    if x: question = question.replace("\'s", '')
    return question


def parseQuestion(question):
    if nerPersonTagging(question): personhit = nerPersonTagging(question)
    else: return "unable to find match"
    if personhit: question = removeName_fromQuery(personhit, question)
    tokenized = nltk.word_tokenize(question)

    nonMatchedWord = []  # list of words (NOT NOUNS) which may be used to break ties with spell checker.
    playerResults = []  # list of results generated by noun search.
    wordResults = []  # list of results generated by nonNouns
    statsResults = []
    capturedWords = []
    minimumQualifiers = ["minimum", "min", "least", "lowest", "smallest", "shortest", "bottom","lesser"]
    maximumQualifiers = ["maximum", "most", "max", "highest", "biggest", "tallest", "top", "heaviest", "higher", "better", "taller", "many", "more"]
    tableName = "placeholder"
    playerName = "placeholder"
    min = False
    max = False
    who = False
    when = False
    location = False
    year = False
    for word in tokenized:
        if "\'" in word:
            tokenized.remove(word)
        elif word == "when":
            when = True
        elif word == "where":
            location = True
        elif word == "who":
            who = True
        elif word.isnumeric():
            if 1949 < int(word) < 2019:
                year = int(word)
        elif word.lower() in minimumQualifiers: min = True
        elif word.lower() in maximumQualifiers: max = True

    tokenized = voila.get_stopwords(tokenized)
    PRE_basewords = tokenized
    tokenized = voila.get_basewords(tokenized)
    voila.addToList(tokenized, capturedWords)
    if personhit:
        if find_searchTable_givenPerson(tokenized): tableInfo,tableName = find_searchTable_givenPerson(tokenized)
        elif find_searchTable_givenPerson(PRE_basewords): tableInfo,tableName = find_searchTable_givenPerson(PRE_basewords)
        else: return "unable to find match"
    # else:
    #     n_Gram = throw_atDB(tokenized, wordResults, playerResults,statsResults, nonMatchedWord)
    #     # function 1 start
    #     tempResults = sqlQuery.search_EXACT_phrase(n_Gram)[0]
    #     if tempResults:
    #         wordResults = tempResults
    #     else:
    #         wordResults = answer.processResults(wordResults, nonMatchedWord)  # processResults begins triangulation.
    #     # process results returns a tuple or list, if tuple we have triangulate, if not we have multiple entires.
    #     if isinstance(wordResults, tuple):
    #         tableName = voila.singlequoteSQLfix(wordResults[5])
    #     else:
    #         wordResults = raw_input_to_N_tuples(n_Gram, wordResults)
    #         if isinstance(wordResults, tuple):
    #             tableName = voila.singlequoteSQLfix(wordResults[5])
    #         # return "there were multiple hits for your query please limit query to only one field or stat at a time"
    #     # function 1 end

    # begin switch/IF statements
    if tableName == "player_data":  # switch case
        if personhit: return getPlayerData(personhit, tableInfo,min, max, year)
        # else:
        #     # old route
        #     val = player_data_true(playerResults, nonMatchedWord)
    elif tableName == "stats":  # switch case
        if personhit: return getStats(personhit, tableInfo, min, max, year, who, when)
        # else:
        #     # old route
        #     val = stats_true(min, max, year, statsResults, wordResults, nonMatchedWord)
    return_info = answer.return_tablename_with_player_name(wordResults, playerName)
    if return_info == 0:
            return "unable to find match"

    return return_info


# 11/26-- we still use this function
def raw_input_to_N_tuples(string, list_of_tuples):
    for row in list_of_tuples:
        if row[0] == string:
            return row


def find_searchTable_givenPerson(tokenized):
    n_Gram = ''
    for word in tokenized:
        result = sqlQuery.search_phrase_DB(word)
        if result: n_Gram = n_Gram + word + ' '
    n_Gram = sqlQuery.search_EXACT_phrase(n_Gram.strip())
    if not n_Gram:
        return 0
    n_Gram = n_Gram[0]
    return n_Gram, n_Gram[5]

def stats_true(min, max, year, statsResults, wordResults, nonMatchedWord):
    # function 3
    if min:
        if year:
            voila.addToList(statsResults, sqlQuery.search_stats_min_DB(wordResults[3], year))
            return statsResults[0][0]
        else:
            voila.addToList(statsResults, sqlQuery.search_stats_min_no_year_DB(wordResults[3]))
            return statsResults[0][0]
    elif max:
        if year:
            voila.addToList(statsResults, sqlQuery.search_stats_max_DB(wordResults[3], year))
            return statsResults[0][0]
        else:
            voila.addToList(statsResults, sqlQuery.search_stats_max_no_year_DB(wordResults[3]))
            return statsResults[0][0]
    else:
        statsResults = answer.processResults(statsResults,
                                             nonMatchedWord)  # processResults begins triangulation.
    if year:
        statsResults = answer.find_with_year(year, statsResults)
    # elif max:
    #     search max of results #max of array
    # elif min:
    #     search min of results #min of array
    elif not isinstance(statsResults, tuple):
        statsResults = voila.get_most_recent(statsResults)
    if isinstance(statsResults, tuple):
        playerName = voila.singlequoteSQLfix(statsResults[0])
        index_for_answer = wordResults[4]
        return statsResults[index_for_answer]
    else:
        return statsResults
        # end function 3

def player_data_true(playerResults, nonMatchedWord):
    # function 2
    playerResults = answer.processResults(playerResults, nonMatchedWord)  # processResults begins triangulation.
    if isinstance(playerResults, tuple):
        playerName = voila.singlequoteSQLfix(playerResults[0])
    else:
        return playerResults
    # end function 2

def getPlayerData(personhit: dict, tableInfo,min, max, year):
    if min and year: pass
    elif min and not year: pass
    elif max and year: pass
    elif max and not year: pass
    elif year and not max and not min: pass
    elif not year and not max and not min:
        for person in personhit.values():
            person = person[1]
            return person[0][tableInfo[4]]

def getMin_from_N_ppl_noDate_returnName(personhit, tableInfo):
    getmin = {}
    for person, personstats in personhit.items():
        personstats = personstats[0]
        getmin[person] = minFrom_one_player_return_name(personstats, tableInfo)
        print(f'name: {person}: min: {minFrom_one_player_return_name(personstats, tableInfo)}')
    return min(getmin, key=getmin.get)

def getstat_by_Year_returnStat(personhit, tableInfo, year):
    for person in personhit.values():
        person = person[0]
        for j in range(len(person)):
            if year == person[j][2]: return person[j][tableInfo[4]]


def getMax_from_N_ppl_noDate_returnName(personhit, tableInfo):
    getmax = {}
    for person, personstats in personhit.items():
        personstats = personstats[0]
        getmax[person] = maxFrom_one_player_return_name(personstats, tableInfo)
        print(f'name: {person}: max: {maxFrom_one_player_return_name(personstats, tableInfo)}')
    return max(getmax, key=getmax.get)

def get_max_onePerson_return_date(personhit: dict, tableInfo):
    highest = [0.0, ""]
    for person in personhit.values():
        person = person[0]
        for i in range(len(person)):
            if float(person[i][tableInfo[4]]) > float(highest[0]):
                highest[0] = person[i][tableInfo[4]]
                highest[1] = i
        return person[highest[1]][2]

def get_min_onePerson_return_date(personhit: dict, tableInfo):
    highest = [999999.0, ""]
    for person in personhit.values():
        person = person[0]
        for i in range(len(person)):
            if float(person[i][tableInfo[4]]) < float(highest[0]):
                highest[0] = person[i][tableInfo[4]]
                highest[1] = i
        return person[highest[1]][2]

def getMin_withYear_andName_returnName(personhit: dict, tableInfo: list, year):
    get_name = {}
    for x,person in personhit.items():
        person = person[0]
        for j in range(len(person)):
            if year == person[j][2]:
                get_name[x] =  float(person[j][tableInfo[4]])
    return min(get_name, key=get_name.get)

def getMax_withYear_andName_returnName(personhit, tableInfo, year):
    get_name = {}
    for x, person in personhit.items():
        person = person[0]
        for j in range(len(person)):
            if year == person[j][2]:
                get_name[x] = float(person[j][tableInfo[4]])
    return max(get_name, key=get_name.get)

def getStats(personhit: dict, tableInfo: list, minr, maxr, year, who, when):
    if when and maxr:
        return get_max_onePerson_return_date(personhit, tableInfo)
    elif when and minr:
        return get_min_onePerson_return_date(personhit, tableInfo)
    elif minr and year and who:
        return getMin_withYear_andName_returnName(personhit, tableInfo, year)
    elif minr and not year and who:
        return getMin_from_N_ppl_noDate_returnName(personhit, tableInfo)
    elif maxr and year and who:
        return getMax_withYear_andName_returnName(personhit, tableInfo, year)
    elif maxr and not year and who:
        return getMax_from_N_ppl_noDate_returnName(personhit, tableInfo)
    elif year and not maxr and not minr:
       return getstat_by_Year_returnStat(personhit, tableInfo, year)
    elif not year and not maxr and not minr:
        for person in personhit.values(): return person[0][len(person[0])-1][tableInfo[4]]
    elif maxr and year:
        return getstat_by_Year_returnStat(personhit, tableInfo, year)
    elif minr:
        return getMin_stat_noYear_returnstat(personhit, tableInfo)
    elif maxr:
        return getMax_stat_noYear_returnstat(personhit, tableInfo)

def getMin_stat_noYear_returnstat(personhit, tableInfo):
    highest = [999999.0, ""]
    for person in personhit.values():
        person = person[0]
        for i in range(len(person)):
            if float(person[i][tableInfo[4]]) < float(highest[0]):
                highest[0] = person[i][tableInfo[4]]
                highest[1] = i
        return person[highest[1]][tableInfo[4]]

def getMax_stat_noYear_returnstat(personhit, tableInfo):
    highest = [0.0, ""]
    for person in personhit.values():
        person = person[0]
        for i in range(len(person)):
            if float(person[i][tableInfo[4]]) > float(highest[0]):
                highest[0] = person[i][tableInfo[4]]
                highest[1] = i
        return person[highest[1]][tableInfo[4]]

def minFrom_one_player_return_name(person: dict, tableInfo):
    highest = [999999.0, ""]
    for i in range(len(person)):
        if float(person[i][tableInfo[4]]) < float(highest[0]):
            highest[0] = person[i][tableInfo[4]]
            highest[1] = i
    return highest[0]


def maxFrom_one_player_return_name(person: dict, tableInfo):
    highest = [0.0, ""]
    for i in range(len(person)):
        if float(person[i][tableInfo[4]]) > float(highest[0]):
            highest[0] = person[i][tableInfo[4]]
            highest[1] = i
    return highest[0]


def throw_atDB(tokenized: list, wordResults, playerResults,statsResults, nonMatchedWord):
    n_Gram = ''
    for word in tokenized:
        result = sqlQuery.search_phrase_DB(word)
        if result:
            voila.addToList(wordResults, result)
            n_Gram = n_Gram + word + ' '
        else:
            result = sqlQuery.search_player_dB(word)
            result_stat = sqlQuery.search_stats_DB(word)
            if result: voila.addToList(playerResults, result)
            if result_stat:
                voila.addToList(statsResults, result_stat)
            else:
                nonMatchedWord.append(word)
    return n_Gram.strip()